

\documentclass[conference,onecolumn]{IEEEtran}

\usepackage[utf8]{inputenc}
\usepackage[pdftex]{graphicx}
%\usepackage{unicode-math}
%\usepackage{mathtools}
\usepackage{amsmath}
\usepackage{float}
\usepackage[pdftex]{hyperref}

\usepackage{filecontents,pgfplots}
\hyphenation{op-tical net-works semi-conduc-tor}


\begin{document}

\renewcommand{\abstractname}{Resumo}
\renewcommand{\refname}{REFERÊNCIAS}
\renewcommand{\tablename}{TABELA}


\title{Análise de Complexidade e Experimental de Algoritmos de Ordenação}


% author names and affiliations
% use a multiple column layout for up to three different
% affiliations
%\author{\IEEEauthorblockN{Bruno Santos de Lima\\Leandro Ungari Cayres}
%\IEEEauthorblockA{Faculdade de Ciências e Tecnologia\\
%Universidade Estadual Paulista\\
%Presidente Prudente, Brasil\\
%\textit{leandroungari@gmail.com}}
%}

\author{ 
 Bruno Santos de Lima\\ 
 \IEEEauthorblockA{Faculdade de Ciências e Tecnologia\\
Universidade Estadual Paulista\\
Presidente Prudente, Brasil \\
 \textit{brunoslima4@gmail.com}
} 
 \and 
 Leandro Ungari Cayres\\ 
 \IEEEauthorblockA{Faculdade de Ciências e Tecnologia\\
Universidade Estadual Paulista\\
Presidente Prudente, Brasil \\
 \textit{leandroungari@gmail.com} 
}
} 



% make the title area
\maketitle

\thispagestyle{plain}
\pagestyle{plain}

% As a general rule, do not put math, special symbols or citations
% in the abstract
%\begin{abstract}
 

%~\\Palavras-chave: ordenação, análise assintótica e análise experimental.

%\end{abstract}


\IEEEpeerreviewmaketitle


\section{Introdução}

Diversas aplicações da atualidade envolvem um grande volume de dados, desde aplicações comerciais simples a grande aplicações científicas. A organização estrutural de conjuntos de dados e sua ordenação, além de prover melhor usabilidade, também otimiza tempo e o consumo de recursos, tanto de processamento quanto de memória para a execução.

Neste contexto, este trabalho apresenta uma análise dos principais algoritmos de ordenação, o qual está dividido nas seguintes seções: na Seção 2, são apresentados os algoritmos de ordenação utilizados, indicando a abordagem utilizada no processo juntamente com a sua respectiva análise assintótica. Na Seção 3, são apresentadas as análises experimental aplicadas em conjuntos de entradas com configurações variadas. A Seção 4 apresenta brevemente uma comparação do número de trocas que cada algoritmo realiza para ordenar cada conjunto de entrada. Por fim, na Seção 5, são apresentadas as considerações finais do estudo.


\section{Algoritmos de Ordenação}


\subsection{Algoritmos baseados em Troca}

~\\
\subsubsection{Bubble Sort}

O presente algoritmo utilizada a abordagem de troca, através da permutação de elementos vizinhos, seguindo a ideia de densidade dos elementos, em que pode-se optar por varrer o arranjo levando o maior elemento (mais pesado) ao fim do vetor, ou conduzir o menor elemento (mais leve) ao início desse. Esse passo (uma das duas opções excludentemente) é realizado sucessivamente para os subvetores não ordenados remanescentes até que o vetor esteja ordenado como um todo \cite{biggar}.

A abordagem original prevê que todos os elementos adjacentes sejam comparados através de $n - 1$ iterações, porém é possível que o arranjo esteja ordenado sem que sejam necessárias todos esses ciclos. De modo a prevenir operações desnecessárias, algumas abordagens utilizam-se de \textit{flags} para a detecção de trocas, caso a última iteração tenha ao menos uma ocorrência, há necessidade de pelo menos mais uma iteração, em caso negativo, o processo pode ser encerrado \cite{biggar}.

\begin{figure}[H]

  \centering
    \includegraphics[width=0.5\textwidth]{images/bubble.png}
    \caption{Modelo de comparação de elementos adjacentes.}        		   \label{image:modelo}
\end{figure}

A Figura~\ref{image:modelo} apresenta a abordagem de ordenação utilizada pelo algoritmo referido.\\

Complexidade:
\begin{itemize}
\item \textbf{Melhor caso:} $O (n)$, para vetor crescente somente na implementação com melhoria.
\item \textbf{Caso médio:} $O (n^2)$.
\item \textbf{Pior caso:} $O (n^2)$, para vetor decrescente e aleatório.
\end{itemize}

~\\
\subsubsection{Quick Sort}

O algoritmo foi proposto por C.A.R. Hoare em 1962, tem como estratégia a divisão do arranjo original em partições a partir da determinação de um pivô. Para qualquer abordagem de escolha do pivô, em cada partição busca-se encontrar os elementos maiores que o pivô a partir do início e os menores a partir do fim do arranjo, os quais são trocados de posição aos pares, de modo a ordenar a partição, se necessário também através da quebra de subpartições \cite{ziviani}.

Em relação a abordagem de escolha de pivô, há diversas técnicas que buscam explorar possíveis características dos elementos do arranjo. Dentre as principais, pode-se destacar a escolha do elemento inicial ou final do vetor, o uso de propriedades estatísticas como a média e mediana, entre outras. O principal objetivo de qualquer uma dessas estratégias é minimizar a ocorrência dos piores casos de recorrência, resultando em um comportamento assintótico quadrático \cite{ziviani}.

Geralmente, os piores caso desse algoritmo consistem na escolha de pivô como elemento mínimo ou máximo, para entradas de dados crescentes e decrescentes.\\

Complexidade:
\begin{itemize}
\item \textbf{Melhor caso:} $O (nlog n)$.
\item \textbf{Caso médio:} $O (nlog n)$.
\item \textbf{Pior caso:} $O (n^2)$, em geral para o pivô mínimo e máximo.
\end{itemize}

~\\
\subsection{Algoritmos baseados em Inserção}

~\\
\subsubsection{Insertion Sort}

A estratégia de ordenação por inserção consiste em um dos métodos mais simples, sendo extremamente eficiente em conjuntos pequenos, com estratégia de percorrer o esquerdo da esquerda para a direita deixando os elementos ordenados  à esquerda. Uma situação cotidiana que aplica a abordagem referida é a inserção de cartas na mão de um jogador, seguindo a estrutura de dados deque \cite{biggar}.\\

Complexidade:
\begin{itemize}
\item \textbf{Melhor caso:} $O (n)$, para arranjo crescente.
\item \textbf{Caso médio:} $O (n^2)$.
\item \textbf{Pior caso:} $O (n^2)$.
\end{itemize}

~\\
\subsubsection{Shell Sort}

O algoritmo Shell Sort foi proposto por Donald Shell em 1959, consistindo em um dos métodos de ordenação mais eficientes dentre os modelos quadráticos, baseando-se no Insertion Sort, a partir de comparações com elementos não adjacentes, desse modo, facilitando o deslocamento dos menores elementos para o início do vetor através do uso de saltos regressivos de tamanho \cite{ziviani}.

O grande diferencial desse método é a utilização dos saltos, porém não existe uma abordagem única para o cálculo do tamanho dos saltos, consistindo em um fator determinante na mensuração da complexidade assintótica \cite{ziviani}. Dentre os principais modelos têm-se o $n$ primeiros múltiplos de um fator ou combinação de fatores (ex. $2^p3^q$) ou os $n$ primeiros números primos.

\begin{figure}[H]

  \centering
    \includegraphics[width=0.75\textwidth]{images/shell.jpg}
     \caption{Modelo de partições com elementos distantes em diferentes tamanhos.}
      \label{image:shell}
\end{figure}

A Figura~\ref{image:shell} apresenta a ordenação das partições de elementos distantes, com saltos de tamanho 40, 13 e 4 respectivamente, partindo do arranjo inicial e alcançando o conjunto ordenado.\\

Complexidade:
\begin{itemize}
\item \textbf{Caso médio:} $O (n^{3/2})$
\end{itemize}
~\\
\subsection{Algoritmos baseados em Seleção}

~\\
\subsubsection{Selection Sort}

O algoritmo Selection Sort, trata-se modelo mais básico de algoritmo de ordenação, utilizada muitas em ambientes naturais e é mais intuitivo para os seres humanos, pois se utiliza da abordagem de força bruta, sem aproveitar nenhuma peculiaridade do conjunto de dados ou vantagem que possa ser tomada. Sua estratégia consiste em percorrer todo o arranjo $n$, comparando todos os elementos de forma a encontrar o menor, em seguida, o segundo menor e assim por diante, de modo a organizar todo o conjunto \cite{ziviani}\cite{biggar}.

O grande destaque para esse algoritmo, dentro do contexto das abordagens quadráticas, consiste no reduzido número de trocas, que no máximo ocorre $n$ vezes \cite{biggar}.\\

Complexidade:
\begin{itemize}
\item \textbf{Caso médio:} $O (n^2)$, de modo invariante.
\end{itemize}

~\\
\subsubsection{Heap Sort}

O algoritmo Heap Sort, proposto por J.W.J. Williams em 1964, possui uma das implementações mais sofisticadas baseando-se em uma fila de prioridades, através da utilização de um vetor para a representação de uma árvore binária, caracterizando como um dos algoritmos mais estáveis de ordenação, independentemente do modelo de dados de entrada \cite{ziviani}. 

\begin{figure}[H]
  
  \centering
    \includegraphics[width=0.6\textwidth]{images/heapsort.jpg}
  \caption{Equivalência entre a árvore e arranjo.}
      \label{image:arvore}
\end{figure}

A Figura~\ref{image:arvore} apresenta o processo de equivalência entre a estrutura de dados Heap na forma de árvore e arranjo.

O algoritmo consiste na construção de um \textit{max heap} (cuja principal propriedade consiste em que sempre o elemento raiz é maior que seus filhos, para todas as sub-árvores possíveis), em seguida, aplica-se a troca do primeiro elemento pelo último para todos os elementos do conjunto (equivalente a remover todos os elementos do arranjo), e posteriormente, rearranjar a estrutura para cada elemento, desse modo é obtido um vetor ordenado de modo crescente ao termino do processo \cite{ziviani}.\\

Complexidade:
\begin{itemize}
\item \textbf{Caso médio:} $O (nlog n)$, de modo invariante.
\end{itemize}

~\\
\subsection{Algoritmos baseados em Intercalação}

~\\
\subsubsection{Merge Sort}

Este algoritmo utiliza o princípio de divisão e conquista, de modo a quebrar um problema complexo em sub-problemas, até o caso base (restante um ou dois elementos no sub-vetor), de modo que seja possível ordená-los. A partir da garantia de que todos os sub-arranjos estão ordenadas, inicia-se o processo de combinação entre eles, de modo recursivo, até alcançar o problema original, de modo ordenado \cite{sedgewick}.

As posições situações de ocorrência são as seguintes:
\begin{itemize}
\item em seu seu melhor caso nunca é necessário realizar trocas após comparações;
\item o caso médio ocorre quando nem sempre é necessário realizar trocas após comparações;
\item por fim, o pior caso ocorre quando sempre é necessário realizar trocas após comparações.
\end{itemize}~\\

Contudo, de modo invariável, todos os casos tem a mesma complexidade assintótica. Adicionalmente, vale-se destacar que diferentemente dos demais algoritmos que não se utilizam de memória adicional, o algoritmo Merge Sort tem complexidade espacial de tamanho $n$, que em dadas situações, deve ser levada em consideração \cite{sedgewick}.

\begin{figure}[H]
  
  \centering
    \includegraphics[width=0.55\textwidth]{images/merge.png}
  \caption{Abordagem de divisão e conquista do algoritmo.}
     \label{image:merge}
\end{figure}

A Figura~\ref{image:merge} apresenta o processo de divisão e conquista utilizado no algoritmo.\\

Complexidade:
\begin{itemize}
\item \textbf{Caso médio:} $O (nlog n)$, de modo invariante.
\end{itemize}

~\\
%==================================
\section{Análise Experimental}

De modo a prover uma análise experimental em relação aos algoritmos, foram conduzidos estudos com diferentes tamanhos de entrada, cujas dimensões foram: 10, 100, 1 000, 10 000, 100 000, 500 000 e 1 000 0000 de elementos, em que para todos os casos foram utilizados como teste um vetor crescente, decrescente e elementos dispersos pelo vetor de forma aleatória (vale ressaltar que para este último foi utilizado um arquivo que armazena os elementos, para que esta sequência aleatória seja sempre a mesma para execução em todos os algoritmos). Todos os casos foram avaliados em relação ao tempo medido em milissegundos (ms) e possuíram três execuções, em que foi escolhido o caso mediano. 

Para a realização da análise experimental foi utilizado um notebook com as seguintes especificações: processador Intel Core i7-7700HQ CPU @ 2.80 GHz de 4 núcleos físicos e 8 threads, com memória cache L1 de 256 KB, L2 de 1 MB, L3 de 6 MB e memória RAM de 8 GB DDR4.


\subsection{Modelos de entrada de dados}
As análises experimentais a seguir realizam uma comparação entre todos os métodos de ordenação para cada caso de entrada de dados específico, sendo ordenado de modo crescente, decrescente e aleatório.
~\\
\subsubsection{Entrada crescente}

Inicialmente, através da Figura~\ref{image: crescente}, pode-se observar que as estratégias de ordenação dos algoritmos \textit{Bubble Sort Clássico}, \textit{Selection Sort} e o \textit{Quick Sort} com pivô inicial apresentaram desempenhos inferiores aos demais, principalmente em relação a esse último, que a partir de uma dada grandeza de entrada superou os outros dois, desse modo é possível notar o impacto que a quebra inadequada de partições pode ocasionar.

Em relação aos outros algoritmos, esses apresentaram melhores desempenhos, assemelhando-se a algoritmos lineares, devido a presença de estratégias que reduzem o número de operações sobre os elementos, com destaque ao \textit{Insertion Sort}, um algoritmo inicialmente quadrático, torna-se o mais eficiente entre os analisados.

\begin{figure}[H]


\centering
\pgfplotstableread{plots/crescente.dat}{\pistonkinetics}
\begin{tikzpicture}[scale=1.5]
\begin{axis}[legend style={at={(0.5,-0.1)},anchor=north}]
\addplot [black,very thick] table [x={n}, y={bubble-class}] {\pistonkinetics};
\addlegendentry{Bubble Sort}
\addplot [red,very thick] table [x={n}, y={bubble-adv}] {\pistonkinetics};
\addlegendentry{Bubble Sort Avançado}
\addplot [blue,very thick] table [x={n}, y={quick-inicial}] {\pistonkinetics};
\addlegendentry{Quick Sort Inicial}
\addplot [green,very thick] table [x={n}, y={quick-central}] {\pistonkinetics};
\addlegendentry{Quick Sort Central}
\addplot [yellow,very thick] table [x={n}, y={insertion}] {\pistonkinetics};
\addlegendentry{Insertion Sort}
\addplot [gray,very thick] table [x={n}, y={shell}] {\pistonkinetics};
\addlegendentry{Shell Sort}
\addplot [brown,very thick] table [x={n}, y={selection}] {\pistonkinetics};
\addlegendentry{Selection Sort}
\addplot [pink,very thick] table [x={n}, y={merge}] {\pistonkinetics};
\addlegendentry{Merge Sort}
\addplot [orange,very thick] table [x={n}, y={heap}] {\pistonkinetics};
\addlegendentry{Heap Sort}
\end{axis}
\end{tikzpicture}
\caption{Comparativo de execução para entrada crescente.}
\label{image: crescente}
\end{figure}

~\\
\subsubsection{Entrada decrescente}

Através do gráfico representado pela Figura~\ref{image: decrescente}, permite-se observar a formação de três conjuntos de desempenho de algoritmos. No primeiro conjunto, pior desempenho, composto pelas duas implementações do \textit{Bubble Sort}, é possível caracterizar o pior caso de ambos, de modo que nenhuma estratégia adicional para otimização tem efeito no desempenho. 

Em seguida, no segundo conjunto, enquadram-se os algoritmos \textit{Insertion Sort}, \textit{Quick Sort} com pivô inicial e \textit{Selection Sort}, com um comportamento próximo de quadrático, porém com um menor número de operações de comparação entre detrimento ao primeiro grupo.

O último caso dessa análise estão os algoritmos \textit{Heap Sort}, \textit{Merge Sort}, \textit{Shell Sort} e \textit{Quick Sort} com pivô central, demonstrando que em dadas situações um algoritmo baseado em inserção pode se equiparar a implementações mais sofisticadas.

\begin{figure}[H]
\centering
\pgfplotstableread{plots/decrescente.dat}{\pistonkinetics}
\begin{tikzpicture}[scale=1.5]
\begin{axis}[legend style={at={(0.5,-0.1)},anchor=north}]
\addplot [black,very thick] table [x={n}, y={bubble-class}] {\pistonkinetics};
\addlegendentry{Bubble Sort}
\addplot [red,very thick] table [x={n}, y={bubble-adv}] {\pistonkinetics};
\addlegendentry{Bubble Sort Avançado}
\addplot [blue,very thick] table [x={n}, y={quick-inicial}] {\pistonkinetics};
\addlegendentry{Quick Sort Inicial}
\addplot [green,very thick] table [x={n}, y={quick-central}] {\pistonkinetics};
\addlegendentry{Quick Sort Central}
\addplot [yellow,very thick] table [x={n}, y={insertion}] {\pistonkinetics};
\addlegendentry{Insertion Sort}
\addplot [gray,very thick] table [x={n}, y={shell}] {\pistonkinetics};
\addlegendentry{Shell Sort}
\addplot [brown,very thick] table [x={n}, y={selection}] {\pistonkinetics};
\addlegendentry{Selection Sort}
\addplot [pink,very thick] table [x={n}, y={merge}] {\pistonkinetics};
\addlegendentry{Merge Sort}
\addplot [orange,very thick] table [x={n}, y={heap}] {\pistonkinetics};
\addlegendentry{Heap Sort}
\end{axis}
\end{tikzpicture}

\caption{Comparativo de execução para entrada decrescente.}
\label{image: decrescente}
\end{figure}

~\\
\subsubsection{Entrada aleatória}

O experimento revelou que para esta organização do conjunto os algoritmos Heap Sort, Merge Sort, Shell e Quick Sort para ambas implementações tiveram um desempenho considerado superior com relação aos demais. Os algoritmos de pior rendimento consistem nas duas implementações do Bubble Sort.

\begin{figure}[H]

\centering
\pgfplotstableread{plots/aleatorio.dat}{\pistonkinetics}
\begin{tikzpicture}[scale=1.5]
\begin{axis}[legend style={at={(0.5,-0.1)}, anchor=north}]
\addplot [black,very thick] table [x={n}, y={bubble-class}] {\pistonkinetics};
\addlegendentry{Bubble Sort}
\addplot [red,very thick] table [x={n}, y={bubble-adv}] {\pistonkinetics};
\addlegendentry{Bubble Sort Avançado}
\addplot [blue,very thick] table [x={n}, y={quick-inicial}] {\pistonkinetics};
\addlegendentry{Quick Sort Inicial}
\addplot [green,very thick] table [x={n}, y={quick-central}] {\pistonkinetics};
\addlegendentry{Quick Sort Central}
\addplot [yellow,very thick] table [x={n}, y={insertion}] {\pistonkinetics};
\addlegendentry{Insertion Sort}
\addplot [gray,very thick] table [x={n}, y={shell}] {\pistonkinetics};
\addlegendentry{Shell Sort}
\addplot [brown,very thick] table [x={n}, y={selection}] {\pistonkinetics};
\addlegendentry{Selection Sort}
\addplot [pink,very thick] table [x={n}, y={merge}] {\pistonkinetics};
\addlegendentry{Merge Sort}
\addplot [orange,very thick] table [x={n}, y={heap}] {\pistonkinetics};
\addlegendentry{Heap Sort}
\end{axis}
\end{tikzpicture}

\caption{Comparativo de execução para entrada aleatório.}
\label{image: aleatoria}
\end{figure}

No último modelo de entrada de dados, representado pela Figura~\ref{image: aleatoria}, é possível observar que os algoritmos \textit{Heap Sort}, \textit{Merge Sort}, \textit{Shell Sort} e \textit{Quick Sort} obtiveram um desempenho com relação aos demais. De modo intermediário, os algoritmos \textit{Selection Sort} e \textit{Insertion} tiveram um desempenho pior se comparado ao primeiro grupo. 

Por fim, os algoritmos de pior rendimento consistem nas duas implementações do \textit{Bubble Sort}, em que deve-se destacar o elevadíssimo número de comparações como principal fator para o rendimento apresentado.

~\\
\subsection{Comparativo por algoritmo}

\subsubsection{Insertion Sort}

Por meio da Figura~\ref{image: graph-insertion}, permite observar que o algoritmo Insertion Sort consiste em um excelente opção para arranjos quase ordenados, pois caracteriza-se com complexidade quase linear, podendo ser muito útil em cenários que haja a construção do conjunto ordenado por demanda, indicado pela curva do arranjo crescente, contudo para os demais casos este torna-se próximo da complexidade quadrática, não consistindo na melhor escolha para tais situações.

\begin{figure}[H]

\centering
\pgfplotstableread{plots/insertion-sort.dat}{\pistonkinetics}
\begin{tikzpicture}[scale=1.3]
\begin{axis}[legend style={at={(0.4,1)}}]
\addplot [black,very thick] table [x={n}, y={ale}] {\pistonkinetics};
\addlegendentry{Aleatório}
\addplot [red,very thick] table [x={n}, y={cresc}] {\pistonkinetics};
\addlegendentry{Crescente}
\addplot [blue,very thick] table [x={n}, y={desc}] {\pistonkinetics};
\addlegendentry{Decrescente}
\end{axis}
\end{tikzpicture}
\caption{Análise experimental do algoritmo Insertion Sort.}
\label{image: graph-insertion}
\end{figure}
~\\
\subsubsection{Shell Sort}
O gráfico representado pela Figura~\ref{image: graph-shell} demostra análise para diferentes casos de entrada do algoritmo Shell Sort, o qual apresenta um comportamento semelhante ao anterior, porém é capaz de lidar com tamanhos de conjunto de dados em um tempo muito mais inferior, enquanto o primeiro trabalha na grandeza de milhões de unidades de tempo, no caso milissegundos, o segundo trabalha na proporção dos milhares. 

Como a sua implementação consiste em uma melhoria da abordagem de inserção, a mesmas indicações de uso valem para este algoritmo.


\begin{figure}[H]

\centering
\pgfplotstableread{plots/shell-sort.dat}{\pistonkinetics}
\begin{tikzpicture}[scale=1.3]
\begin{axis}[legend style={at={(0.4,1)}}]
\addplot [black,very thick] table [x={n}, y={ale}] {\pistonkinetics};
\addlegendentry{Aleatório}
\addplot [red,very thick] table [x={n}, y={cresc}] {\pistonkinetics};
\addlegendentry{Crescente}
\addplot [blue,very thick] table [x={n}, y={desc}] {\pistonkinetics};
\addlegendentry{Decrescente}
\end{axis}
\end{tikzpicture}
\caption{Análise experimental do algoritmo Shell Sort.}
\label{image: graph-shell}
\end{figure}
~\\
\subsubsection{Selection Sort}

Através do gráfico representado pela Figura~\ref{image: graph-selection}, pode-se concluir que o algoritmo de ordenação Selection Sort, apesar de ser indiferente quanto a organização prévia dos elementos pertencentes ao arranjo e ter uma das mais simples implementações, caracterizando-se como força-bruta, torna-se pior a medida que o número de elementos cresce, cuja curva se assemelha às quadráticas.

\begin{figure}[H]


\centering
\pgfplotstableread{plots/selection-sort.dat}{\pistonkinetics}
\begin{tikzpicture}[scale=1.3]
\begin{axis}[legend style={at={(0.4,1)}}]
\addplot [black,very thick] table [x={n}, y={ale}] {\pistonkinetics};
\addlegendentry{Aleatório}
\addplot [red,very thick] table [x={n}, y={cresc}] {\pistonkinetics};
\addlegendentry{Crescente}
\addplot [blue,very thick] table [x={n}, y={desc}] {\pistonkinetics};
\addlegendentry{Decrescente}
\end{axis}
\end{tikzpicture}
\caption{Análise experimental do algoritmo Selection Sort.}
\label{image: graph-selection}
\end{figure}



~\\
\subsubsection{Heap Sort}

Para a análise do algoritmo de ordenação \textit{Heap Sort} é possível observar, através do gráfico representado pela Figura~\ref{image: graph-heap} que os melhores casos são para entradas crescentes e decrescentes, enquanto que para o caso aleatório é registrado uma complexidade de tempo. 

Como grande destaque, de modo invariante para entrada de dados, este consiste o único algoritmo que realizou todos os testes experimentais dentro da grandeza de centenas de millissegundos, não alcançando os 300 ms para as maiores entradas de dados.

\begin{figure}[H]

\centering
\pgfplotstableread{plots/heap-sort.dat}{\pistonkinetics}
\begin{tikzpicture}[scale=1.3]
\begin{axis}[legend style={at={(0.4,1)}}]
\addplot [black,very thick] table [x={n}, y={ale}] {\pistonkinetics};
\addlegendentry{Aleatório}
\addplot [red,very thick] table [x={n}, y={cresc}] {\pistonkinetics};
\addlegendentry{Crescente}
\addplot [blue,very thick] table [x={n}, y={desc}] {\pistonkinetics};
\addlegendentry{Decrescente}
\end{axis}
\end{tikzpicture}
\caption{Análise experimental do algoritmo Heap Sort.}
\label{image: graph-heap}
\end{figure}

~\\
\subsubsection{Bubble Sort}

O estudo experimental, apresentado na Figura~\ref{image: graph-bubble} realizado com o método de ordenação \textit{Bubble Sort} original, demonstra que independentemente da entrada de dados, o comportamento é semelhante, considerado de ordem quadrática, em que, de modo adicional, para um vetor crescente seu desempenho foi levemente superior aos demais devido ao número reduzido de trocas entre elementos.

\begin{figure}[H]

\centering
\pgfplotstableread{plots/bubble-sort.dat}{\pistonkinetics}
\begin{tikzpicture}[scale=1.3]
\begin{axis}[legend style={at={(0.4,1)}}]
\addplot [black,very thick] table [x={n}, y={ale}] {\pistonkinetics};
\addlegendentry{Aleatório}
\addplot [red,very thick] table [x={n}, y={cresc}] {\pistonkinetics};
\addlegendentry{Crescente}
\addplot [blue,very thick] table [x={n}, y={desc}] {\pistonkinetics};
\addlegendentry{Decrescente}
\end{axis}
\end{tikzpicture}
\caption{Análise experimental do algoritmo Bubble Sort.}
\label{image: graph-bubble}
\end{figure}

Em contraponto, a implementação com  com melhorias do algoritmo \textit{Bubble Sort}, representado pela Figura~\ref{image: graph-bubble-adv}, apresenta como melhor caso o arranjo crescente, registrando um desempenho linear. Para os demais casos de entrada, o comportamento quadrático novamente é registrado, e torna-se mais evidente de modo proporcional ao crescimento do conjunto de entrada.

\begin{figure}[H]

\centering
\pgfplotstableread{plots/bubble-sort-adv.dat}{\pistonkinetics}
\begin{tikzpicture}[scale=1.3]
\begin{axis}[legend style={at={(0.4,1)}}]
\addplot [black,very thick] table [x={n}, y={ale}] {\pistonkinetics};
\addlegendentry{Aleatório}
\addplot [red,very thick] table [x={n}, y={cresc}] {\pistonkinetics};
\addlegendentry{Crescente}
\addplot [blue,very thick] table [x={n}, y={desc}] {\pistonkinetics};
\addlegendentry{Decrescente}
\end{axis}
\end{tikzpicture}
\caption{Análise experimental do algoritmo Bubble Sort Avançado.}
\label{image: graph-bubble-adv}
\end{figure}

~\\
\subsubsection{Quick Sort}
A análise experimental realizada para o algoritmo \textit{Quick Sort} com pivô inicial, representada pela Figura~\ref{image: graph-quick-inicial} apresentou bom desempenho para um conjunto aleatório, contudo para ordem crescente e decrescente, o processo de teste determinou desempenho inferior de forma considerável.

\begin{figure}[H]

\centering
\pgfplotstableread{plots/quick-sort-pivo-inicial.dat}{\pistonkinetics}
\begin{tikzpicture}[scale=1.3]
\begin{axis}[legend style={at={(0.4,1)}}]
\addplot [black,very thick] table [x={n}, y={ale}] {\pistonkinetics};
\addlegendentry{Aleatório}
\addplot [red,very thick] table [x={n}, y={cresc}] {\pistonkinetics};
\addlegendentry{Crescente}
\addplot [blue,very thick] table [x={n}, y={desc}] {\pistonkinetics};
\addlegendentry{Decrescente}
\end{axis}
\end{tikzpicture}
\caption{Análise experimental do algoritmo Quick Sort com pivô inicial.}
\label{image: graph-quick-inicial}
\end{figure}


Por outro lado, considerando a implementação do algoritmo \textit{Quick Sort} utilizando pivô central, é notório que nos casos em que o vetor está inicialmente ordenado de modo crescente e decrescente o desempenho é superior em detrimento ao arranjo  disposto aleatoriamente. 

Vale-se destacar a disparidade na grandeza de tempo entre a abordagem de pivô e central. Em ambos os casos, para a maior entrada de dados, a primeira opção requereu tempo superior a 1 000 000 ms, enquanto o segundo requereu um pouco mais que 150 ms.

\begin{figure}[H]
\centering
\pgfplotstableread{plots/quick-sort-pivo-central.dat}{\pistonkinetics}
\begin{tikzpicture}[scale=1.3]
\begin{axis}[legend style={at={(0.4,1)}}]
\addplot [black,very thick] table [x={n}, y={ale}] {\pistonkinetics};
\addlegendentry{Aleatório}
\addplot [red,very thick] table [x={n}, y={cresc}] {\pistonkinetics};
\addlegendentry{Crescente}
\addplot [blue,very thick] table [x={n}, y={desc}] {\pistonkinetics};
\addlegendentry{Decrescente}

\end{axis}
\end{tikzpicture}
\caption{Análise experimental do algoritmo Quick Sort com pivô central.}
\label{image: graph-quick-central}
\end{figure}

~\\
\subsubsection{Merge Sort}

Por fim, para o algoritmo \textit{Merge Sort} que possui implementação baseada em divisão e conquista, a análise representada pela Figura~\ref{image: graph-merge}, permite o processo de ordenação de modo quase indiferente em relação ao modelo de entrada de dados. De modo específico, é possível observar uma pequena vantagem para conjunto decrescentes e crescentes em detrimento ao aleatório.

\begin{figure}[H]

\centering
\pgfplotstableread{plots/merge-sort.dat}{\pistonkinetics}
\begin{tikzpicture}[scale=1.3]
\begin{axis}[legend style={at={(0.4,1)}}]
\addplot [black,very thick] table [x={n}, y={ale}] {\pistonkinetics};
\addlegendentry{Aleatório}
\addplot [red,very thick] table [x={n}, y={cresc}] {\pistonkinetics};
\addlegendentry{Crescente}
\addplot [blue,very thick] table [x={n}, y={desc}] {\pistonkinetics};
\addlegendentry{Decrescente}
\end{axis}
\end{tikzpicture}
\caption{Análise experimental do algoritmo Merge Sort.}
\label{image: graph-merge}
\end{figure}

~\\
\subsection{Comparativo de abordagem}

Todas as comparações abaixo foram realizadas utilizando os casos para conjunto de dados aleatório e também com as melhores implementações de cada algoritmo, de forma a não favorecer determinados algoritmos e consequentemente propor conclusões equivocadas.
~\\
\subsubsection{Abordagem de inserção}

A comparação entre os algoritmos com abordagem de ordenação baseada em inserção, representado pela Figura~\ref{image: graph-insercao} indica uma enorme superioridade para o algoritmo \textit{Shell Sort} em detrimento ao \textit{Insertion Sort}, a qual se eleva ainda mais após entradas de tamanho 500 000, demonstrando que uso de saltos para ordenação em sub-partições é essencial, proporcionando grande ganho de desempenho.

\begin{figure}[H]
\centering
\pgfplotstableread{plots/insercao.dat}{\pistonkinetics}
\begin{tikzpicture}[scale=1.3]
\begin{axis}[legend style={at={(0.45,1)}}]
\addplot [black,very thick] table [x={n}, y={insertion}] {\pistonkinetics};
\addlegendentry{Insertion Sort}
\addplot [red,very thick] table [x={n}, y={shell}] {\pistonkinetics};
\addlegendentry{Shell Sort}
\end{axis}
\end{tikzpicture}
\caption{Comparativo de algoritmos baseados em inserção.}
\label{image: graph-insercao}
\end{figure}
~\\
\subsubsection{Abordagem de troca}

Para o comparativo dos algoritmos de ordenação baseados em troca, através da Figura~\ref{image: graph-troca}, pode-se observar que o algoritmo \textit{Quick Sort} com pivô central tem custo de processamento extremamente inferior em relação ao \textit{Bubble Sort} com melhorias. Desse modo, vale ressaltar que a ordenação através de sub-partições e a escolha adequada de um pivô proporcionam um resultado muito superior do que a comparação direta entre vizinhos usada no \textit{Bubble Sort}.
\begin{figure}[H]

\centering
\pgfplotstableread{plots/troca.dat}{\pistonkinetics}
\begin{tikzpicture}[scale=1.3]
\begin{axis}[legend style={at={(0.4,1)}}]
\addplot [black,very thick] table [x={n}, y={bubble}] {\pistonkinetics};
\addlegendentry{Bubble Sort}
\addplot [red,very thick] table [x={n}, y={quick}] {\pistonkinetics};
\addlegendentry{Quick Sort}
\end{axis}
\end{tikzpicture}
\caption{Comparativo de algoritmos baseados em troca.}
\label{image: graph-troca}
\end{figure}

~\\
\subsubsection{Abordagem de seleção}
Por fim, o comparativo da abordagem de ordenação baseada em seleção, representada pela Figura~\ref{image: graph-selecao}, indique um desempenho extremamente superior do algoritmo \textit{Heap Sort}, que utiliza a ideia de fila de prioridades, em detrimento ao algoritmo \textit{Selection Sort}, que utiliza uma ideia intuitiva, porém caracterizada como força-bruta, sem qualquer inteligência do método ou aproveitamento de propriedades do conjunto de dados.

\begin{figure}[H]

\centering
\pgfplotstableread{plots/selecao.dat}{\pistonkinetics}
\begin{tikzpicture}[scale=1.3]
\begin{axis}[legend style={at={(0.45,1)}}]
\addplot [black,very thick] table [x={n}, y={selection}] {\pistonkinetics};
\addlegendentry{Selection Sort}
\addplot [red,very thick] table [x={n}, y={heap}] {\pistonkinetics};
\addlegendentry{Heap Sort}
\end{axis}
\end{tikzpicture}
\caption{Comparativo de algoritmos baseados em seleção.}
\label{image: graph-selecao}
\end{figure}

\section{Análise quantidade de trocas realizadas}

Além da análise experimental que visa comparar os tempos de execução entre os diversos algoritmos de ordenação, também foi aplicada uma análise com objetivo de comparar a quantidade de trocas de posições de elementos durante uma ordenação. Foi medido durante a execução dos algoritmos a quantidade máxima de troca que eles realizam de acordo com os três tipos de entrada (aleatória, crescente e decrescente) em diferentes dimensões.

\subsubsection{Entrada aleatória}

A Figura \ref{graf:trocas-aleatoria} apresenta um gráfico que contem o número de trocas de todos os algoritmos. Nesta figura é possivel observar em amarelo representado pelo Insertion Sort que realiza um maior número de trocas, existe uma sobreposição na linha em amarelo, pois o Bubble Sort e o Bubble Sort também tem exatamente o mesmo comportamento que o Insertion Sort, sendos os algoritmos que mais realizam trocas para está configuração de entrada. Além desses, o Shell Sort também realiza um número grande de trocas. Os demais algoritmos não são possíveis de ser observados nesta imagem, por terem número de trocas bem menores, assim eles foram colocados isoladamente na Figura \ref{graf:trocas-aleatoria-menores}.

\begin{figure}[H]
\begin{center}
\pgfplotstableread{plots/swap/aleatorio-troca.dat}{\pistonkinetics}
\begin{tikzpicture}[scale=1.3]
\begin{axis}[legend style={at={(1.4,0.85)},anchor=north}]
\addplot [black,very thick] table [x={n}, y={bubble-class}] {\pistonkinetics};
\addlegendentry{Bubble Sort}
\addplot [red,very thick] table [x={n}, y={bubble-adv}] {\pistonkinetics};
\addlegendentry{Bubble Sort Avançado}
\addplot [blue,very thick] table [x={n}, y={quick-inicial}] {\pistonkinetics};
\addlegendentry{Quick Sort Inicial}
\addplot [green,very thick] table [x={n}, y={quick-central}] {\pistonkinetics};
\addlegendentry{Quick Sort Central}
\addplot [yellow,very thick] table [x={n}, y={insertion}] {\pistonkinetics};
\addlegendentry{Insertion Sort}
\addplot [gray,very thick] table [x={n}, y={shell}] {\pistonkinetics};
\addlegendentry{Shell Sort}
\addplot [brown,very thick] table [x={n}, y={selection}] {\pistonkinetics};
\addlegendentry{Selection Sort}
\addplot [pink,very thick] table [x={n}, y={merge}] {\pistonkinetics};
\addlegendentry{Merge Sort}
\addplot [orange,very thick] table [x={n}, y={heap}] {\pistonkinetics};
\addlegendentry{Heap Sort}
\end{axis}
\end{tikzpicture}
\end{center}
\caption{Número de trocas realizadas pelos algoritmos para entrada com elementos em ordem aleatória.}
\label{graf:trocas-aleatoria}
\end{figure}

Na Figura \ref{graf:trocas-aleatoria-menores} é possível observar os algoritmos que realizam menores números de trocas em entrada aleatória. Dentre eles o Heap Sort e o Merge Sort realizam mais trocas, seguidos das duas implementações do Quick Sort e é notório também que o algoritmo Selection Sort realiza menos trocas em conjuntos de entrada aleatória. Todos os algoritmos para essa situação tem um comportamento linear.

\begin{figure}[H]
\begin{center}
\pgfplotstableread{plots/swap/aleatorio-troca-menores.dat}{\pistonkinetics}
\begin{tikzpicture}[scale=1.3]
\begin{axis}[legend style={at={(1.4,0.65)},anchor=north}]
\addplot [blue,very thick] table [x={n}, y={quick-inicial}] {\pistonkinetics};
\addlegendentry{Quick Sort Inicial}
\addplot [green,very thick] table [x={n}, y={quick-central}] {\pistonkinetics};
\addlegendentry{Quick Sort Central}
\addplot [brown,very thick] table [x={n}, y={selection}] {\pistonkinetics};
\addlegendentry{Selection Sort}
\addplot [pink,very thick] table [x={n}, y={merge}] {\pistonkinetics};
\addlegendentry{Merge Sort}
\addplot [orange,very thick] table [x={n}, y={heap}] {\pistonkinetics};
\addlegendentry{Heap Sort}
\end{axis}
\end{tikzpicture}
\end{center}
\caption{Número de trocas realizadas pelos algoritmos para entrada com elementos em ordem aleatória.}
\label{graf:trocas-aleatoria-menores}
\end{figure}

\subsubsection{Entrada crescente}

A Figura \ref{graf:trocas-crescente} apresenta um gráfico com o comportamento em relação ao número de trocas para uma entrada crescente. Contudo visualiza-los todos juntos causa uma certa sobreposição. Para melhorar a visualização das análises foram exibidos juntos os algoritmos que mais realizam trocas, depois os que menos realizam trocas e por fim os que realizam um número total de trocas com valores intermediários com relação aos que mais e menos realizam trocas.

\begin{figure}[H]
\begin{center}
\pgfplotstableread{plots/swap/crescente-troca.dat}{\pistonkinetics}
\begin{tikzpicture}[scale=1.3]
\begin{axis}[legend style={at={(1.4,0.85)},anchor=north}]
\addplot [black,very thick] table [x={n}, y={bubble-class}] {\pistonkinetics};
\addlegendentry{Bubble Sort}
\addplot [red,very thick] table [x={n}, y={bubble-adv}] {\pistonkinetics};
\addlegendentry{Bubble Sort Avançado}
\addplot [blue,very thick] table [x={n}, y={quick-inicial}] {\pistonkinetics};
\addlegendentry{Quick Sort Inicial}
\addplot [green,very thick] table [x={n}, y={quick-central}] {\pistonkinetics};
\addlegendentry{Quick Sort Central}
\addplot [yellow,very thick] table [x={n}, y={insertion}] {\pistonkinetics};
\addlegendentry{Insertion Sort}
\addplot [gray,very thick] table [x={n}, y={shell}] {\pistonkinetics};
\addlegendentry{Shell Sort}
\addplot [brown,very thick] table [x={n}, y={selection}] {\pistonkinetics};
\addlegendentry{Selection Sort}
\addplot [pink,very thick] table [x={n}, y={merge}] {\pistonkinetics};
\addlegendentry{Merge Sort}
\addplot [orange,very thick] table [x={n}, y={heap}] {\pistonkinetics};
\addlegendentry{Heap Sort}
\end{axis}
\end{tikzpicture}
\end{center}
\caption{Número de trocas realizadas pelos algoritmos para entrada com elementos em ordem crescente.}
\label{graf:trocas-crescente}
\end{figure}

A Figura \ref{graf:trocas-crescente-mais} apresenta a evolução do número de trocas dos algoritmos que mais fazem trocas, sendo eles Heap Sort e Merge Sort. O número de trocas que ambos fazem é bem semelhante, contudo o Merge Sort realiza um pouco mais trocas que o Heap Sort.

\begin{figure}[H]
\begin{center}
\pgfplotstableread{plots/swap/crescente-troca.dat}{\pistonkinetics}
\begin{tikzpicture}[scale=1]
\begin{axis}[legend style={at={(0.5,-0.1)},anchor=north}]
\addplot [pink,very thick] table [x={n}, y={merge}] {\pistonkinetics};
\addlegendentry{Merge Sort}
\addplot [orange,very thick] table [x={n}, y={heap}] {\pistonkinetics};
\addlegendentry{Heap Sort}
\end{axis}
\end{tikzpicture}
\end{center}
\caption{Algoritmos que mais realizam trocas para entrada com elementos em ordem crescente.}
\label{graf:trocas-crescente-mais}
\end{figure}

A Figura \ref{graf:trocas-crescente-menos} apresenta os algoritmos que menos realizam trocas para entrada crescente. No caso, eles não realizam nenhuma troca, pois seu principio de implementação verifica a necessidade ou não de realizar trocas, como o conjunto já está ordenado não é necessário realizar trocas.

\begin{figure}[H]
\begin{center}
\pgfplotstableread{plots/swap/crescente-troca.dat}{\pistonkinetics}
\begin{tikzpicture}[scale=1]
\begin{axis}[legend style={at={(1.4,0.65)},anchor=north}]
\addplot [black,very thick] table [x={n}, y={bubble-class}] {\pistonkinetics};
\addlegendentry{Bubble Sort}
\addplot [red,very thick] table [x={n}, y={bubble-adv}] {\pistonkinetics};
\addlegendentry{Bubble Sort Avançado}
\addplot [yellow,very thick] table [x={n}, y={insertion}] {\pistonkinetics};
\addlegendentry{Insertion Sort}
\addplot [gray,very thick] table [x={n}, y={shell}] {\pistonkinetics};
\addlegendentry{Shell Sort}
\addplot [brown,very thick] table [x={n}, y={selection}] {\pistonkinetics};
\addlegendentry{Selection Sort}
\end{axis}
\end{tikzpicture}
\end{center}
\caption{Algoritmos que menos realizam trocas para entrada com elementos em ordem crescente..}
\label{graf:trocas-crescente-menos}
\end{figure}

Por fim, a Figura \ref{graf:trocas-crescente-mediano} apresenta os algoritmos que não fazem nem o maior nem o menor número de trocas, sendo eles as implementações do Quick Sort. Quando o Quick Sort é implementado de modo que o pivô é central ele faz menos trocas se comparado com o Quick Sort de implementação de pivô inicial.

\begin{figure}[H]
\begin{center}
\pgfplotstableread{plots/swap/crescente-troca.dat}{\pistonkinetics}
\begin{tikzpicture}[scale=1.3]
\begin{axis}[legend style={at={(0.5,-0.1)},anchor=north}]
\addplot [blue,very thick] table [x={n}, y={quick-inicial}] {\pistonkinetics};
\addlegendentry{Quick Sort Inicial}
\addplot [green,very thick] table [x={n}, y={quick-central}] {\pistonkinetics};
\addlegendentry{Quick Sort Central}
\end{axis}
\end{tikzpicture}
\end{center}
\caption{Algoritmos que realizam um número mediano de trocas para entrada com elementos em ordem crescente..}
\label{graf:trocas-crescente-mediano}
\end{figure}

\subsubsection{Entrada decrescente}

Para entradas com elementos dispostos em ordem decrescente os algoritmos que mais fazem trocas para ordenar o conjunto são o Bubble Sort (ambas implementações) e o Insertion Sort, seguidos pelo Shell Sort, observe a Figura \ref{graf:trocas-decrescente}

\begin{figure}[H]
\begin{center}
\pgfplotstableread{plots/swap/decrescente-troca.dat}{\pistonkinetics}
\begin{tikzpicture}[scale=1.3]
\begin{axis}[legend style={at={(1.4,0.85)},anchor=north}]
\addplot [black,very thick] table [x={n}, y={bubble-class}] {\pistonkinetics};
\addlegendentry{Bubble Sort}
\addplot [red,very thick] table [x={n}, y={bubble-adv}] {\pistonkinetics};
\addlegendentry{Bubble Sort Avançado}
\addplot [blue,very thick] table [x={n}, y={quick-inicial}] {\pistonkinetics};
\addlegendentry{Quick Sort Inicial}
\addplot [green,very thick] table [x={n}, y={quick-central}] {\pistonkinetics};
\addlegendentry{Quick Sort Central}
\addplot [yellow,very thick] table [x={n}, y={insertion}] {\pistonkinetics};
\addlegendentry{Insertion Sort}
\addplot [gray,very thick] table [x={n}, y={shell}] {\pistonkinetics};
\addlegendentry{Shell Sort}
\addplot [brown,very thick] table [x={n}, y={selection}] {\pistonkinetics};
\addlegendentry{Selection Sort}
\addplot [pink,very thick] table [x={n}, y={merge}] {\pistonkinetics};
\addlegendentry{Merge Sort}
\addplot [orange,very thick] table [x={n}, y={heap}] {\pistonkinetics};
\addlegendentry{Heap Sort}
\end{axis}
\end{tikzpicture}
\end{center}
\caption{Número de trocas realizadas pelos algoritmos para entrada com elementos em ordem decrescente.}
\label{graf:trocas-decrescente}
\end{figure}

Na Figura anterior não foi possível observar com exatidão o numero de trocas dos demais algoritmos, então eles foram agrupados na Figura \ref{graf:trocas-decrescente-menos} que ilustra a evolução do número de trocas de cada um deles. O algoritmo que menos faz troca para esta configuração de entrada é o Selection Sort, seguido pelas implementações do Quick Sort. Dentre esses algoritmos o Merge Sort e Heap Sort fazem mais bem mais trocas, porem ainda não fazem mais trocas que o Bubble Sort e Insertion Sort. O Merge Sort realiza um pouco mais de trocas que o Heap Sort.

\begin{figure}[H]
\begin{center}
\pgfplotstableread{plots/swap/decrescente-troca.dat}{\pistonkinetics}
\begin{tikzpicture}[scale=1.3]
\begin{axis}[legend style={at={(1.4,0.85)},anchor=north}]
\addplot [blue,very thick] table [x={n}, y={quick-inicial}] {\pistonkinetics};
\addlegendentry{Quick Sort Inicial}
\addplot [green,very thick] table [x={n}, y={quick-central}] {\pistonkinetics};
\addlegendentry{Quick Sort Central}
\addplot [brown,very thick] table [x={n}, y={selection}] {\pistonkinetics};
\addlegendentry{Selection Sort}
\addplot [pink,very thick] table [x={n}, y={merge}] {\pistonkinetics};
\addlegendentry{Merge Sort}
\addplot [orange,very thick] table [x={n}, y={heap}] {\pistonkinetics};
\addlegendentry{Heap Sort}
\end{axis}
\end{tikzpicture}
\end{center}
\caption{Número de trocas realizadas pelos algoritmos para entrada com elementos em ordem decrescente.}
\label{graf:trocas-decrescente-menos}
\end{figure}

\subsection{Análise número de trocas por algoritmo}

Após observar o comportamento do número de trocas com uma visão de todos os algoritmos juntos, agora é exposto esse comportamento considerando cada algoritmo individualmente, afim de perceber as diferenças existentes nos três tipos distintos de entradas (aleatório, crescente e decrescente).

~\\
\subsubsection{Bubble Sort e Insertion Sort}

Considerando o número de trocas necessário para ordenar um conjunto de dados, após a análise realizada foi constatado que os algoritmos implementados: Bubble Sort (implementação clássica e melhorada) e Insertion Sort, tiveram o mesmo comportamento, ou seja, o mesmo número de trocas. Tal comportamento pode ser observado na Figura \ref{graf:bubble-sort-melhorado-troca}.

Para a entrada crescente nenhuma troca foi realizada como era esperado, contudo para a entrada organizada em ordem decrescente tem-se um grande número de trocas principalmente para ordenar conjuntos maiores que 500000, sendo para conjuntos de entrada em ordem decrescente o pior caso de trocas realizadas. A entrada aleatória realiza um número menor de trocas se comparado com uma entrada com elementos em ordem descrescente, porem ainda assim realiza uma quantidade de trocas consideráveis, sendo bem maior que para entradas em ordem crescente que não realiza nenhuma troca.

\begin{figure}[H]
\begin{center}
\pgfplotstableread{plots/swap/bubble-sort-adv-troca.dat}{\pistonkinetics}
\begin{tikzpicture}[scale=1.3]
\begin{axis}[minor tick num=1,
xlabel=n elementos]
\addlegendentry{Aleatório}
\addplot [black,very thick] table [x={n}, y={ale}] {\pistonkinetics};
\addlegendentry{Crescente}
\addplot [red,very thick] table [x={n}, y={cresc}] {\pistonkinetics};
\addlegendentry{Decrescente}
\addplot [blue,very thick] table [x={n}, y={desc}] {\pistonkinetics};
\end{axis}
\end{tikzpicture}
\end{center}
\caption{Número de trocas realizadas pelo algoritmo Bubble Sort melhorado.}
\label{graf:bubble-sort-melhorado-troca}
\end{figure}

\subsubsection{Quick Sort Pivô inicial}

O algoritmo Quick Sort com implementação colocando sempre o pivô como ponto inicial tem números de trocas que apresentam comportamento linear. O maior número de trocas ocorre quando a entrada está organizada em ordem aleatória, entretanto os casos em que a entrada está em ordem crescente ou decrescente a quantidade de trocas é a mesma para essas duas entradas, vale ressaltar ainda que a quantidade de trocas na entrada em ordem aleatória é bem maior que a quantidade de trocas nas duas outras configurações de entrada. Observe o gráfico apresentado na Figura \ref{graf:quick-inicial-troca}.

\begin{figure}[H]
\begin{center}
\pgfplotstableread{plots/swap/quick-sort-pivo-inicial-troca.dat}{\pistonkinetics}
\begin{tikzpicture}[scale=1.3]
\begin{axis}[minor tick num=1,
xlabel=n elementos]
\addlegendentry{Aleatório}
\addplot [black,very thick] table [x={n}, y={ale}] {\pistonkinetics};
\addlegendentry{Crescente}
\addplot [red,very thick] table [x={n}, y={cresc}] {\pistonkinetics};
\addlegendentry{Decrescente}
\addplot [blue,very thick] table [x={n}, y={desc}] {\pistonkinetics};
\end{axis}
\end{tikzpicture}
\end{center}
\caption{Número de trocas realizadas pelo algoritmo Quick Sort implementação com pivô inicial.}
\label{graf:quick-inicial-troca}
\end{figure}

\subsubsection{Quick Sort Pivô Central}

Quando o algoritmo Quick Sort é implementado com o pivo sendo sempre o elemento central o comportamento de número de trocas é diferente a implementação com pivô sendo sempre o inicial. Neste caso, o maior número de trocas absoluto continua sendo para a entrada organizada de modo aleatório, contudo a diferença entra a implementação discutida anteriormente está que o número de trocas para entradas em ordem crescente e decrescente é diferente, tendo maior quantidade de trocas para a decrescente e menor para a entrada em ordem crescente. Observe o gráfico apresentado na Figura \ref{graf:quick-central-troca}.

\begin{figure}[H]
\begin{center}
\pgfplotstableread{plots/swap/quick-sort-pivo-central-troca.dat}{\pistonkinetics}
\begin{tikzpicture}[scale=1.3]
\begin{axis}[minor tick num=1,
xlabel=n elementos]
\addlegendentry{Aleatório}
\addplot [black,very thick] table [x={n}, y={ale}] {\pistonkinetics};
\addlegendentry{Crescente}
\addplot [red,very thick] table [x={n}, y={cresc}] {\pistonkinetics};
\addlegendentry{Decrescente}
\addplot [blue,very thick] table [x={n}, y={desc}] {\pistonkinetics};
\end{axis}
\end{tikzpicture}
\end{center}
\caption{Número de trocas realizadas pelo algoritmo Quick Sort implementação com pivô central.}
\label{graf:quick-central-troca}
\end{figure}

\subsubsection{Shell Sort}

O Shell Sort não realiza nenhuma troca quando a entrada de dados está em ordem decrescente, a verificação presente no corpo do algoritmo garante isso. Contudo, para os outros demais casos existem uma quantidade de trocas significativa de comportamento não linear, porem quanto maior a dimensão da entra maior o número de trocas. A maior quantidade de trocas ocorre com a entrada em ordem decrescente e a segunda maior em ordem aleatória. Observe o gráfico apresentado na Figura \ref{graf:shell-troca}.

\begin{figure}[H]
\begin{center}
\pgfplotstableread{plots/swap/shell-sort-troca.dat}{\pistonkinetics}
\begin{tikzpicture}[scale=1.3]
\begin{axis}[minor tick num=1,
xlabel=n elementos]
\addlegendentry{Aleatório}
\addplot [black,very thick] table [x={n}, y={ale}] {\pistonkinetics};
\addlegendentry{Crescente}
\addplot [red,very thick] table [x={n}, y={cresc}] {\pistonkinetics};
\addlegendentry{Decrescente}
\addplot [blue,very thick] table [x={n}, y={desc}] {\pistonkinetics};
\end{axis}
\end{tikzpicture}
\end{center}
\caption{Número de trocas realizadas pelo algoritmo Shell Sort.}
\label{graf:shell-troca}
\end{figure}

\subsubsection{Selection Sort}

No algoritmo Selection Sort todas as quantidades de trocas tem valores bem espaçados entre as três configurações de entrada. Neste caso, a que menos realiza trocas são quando a entrada está em ordem crescente, neste caso, nenhuma troca é realizada, pois, o algoritmo verifica que os elementos já estão em ordem correta. Já nas duas demais configurações de entrada ocorrem um número de trocas acentuado, sendo o maior deles na entrada em ordem aleatória e a segundo maior na entrada em ordem decrescente. Observe o gráfico apresentado na Figura \ref{graf:selection-troca}.

\begin{figure}[H]
\begin{center}
\pgfplotstableread{plots/swap/selection-sort-troca.dat}{\pistonkinetics}
\begin{tikzpicture}[scale=1.3]
\begin{axis}[minor tick num=1,
xlabel=n elementos]
\addlegendentry{Aleatório}
\addplot [black,very thick] table [x={n}, y={ale}] {\pistonkinetics};
\addlegendentry{Crescente}
\addplot [red,very thick] table [x={n}, y={cresc}] {\pistonkinetics};
\addlegendentry{Decrescente}
\addplot [blue,very thick] table [x={n}, y={desc}] {\pistonkinetics};
\end{axis}
\end{tikzpicture}
\end{center}
\caption{Número de trocas realizadas pelo algoritmo Selection Sort.}
\label{graf:selection-troca}
\end{figure}

\subsubsection{Merge Sort}

O algoritmo Merge Sort independentemente da configuração de entrada sempre irá realizar o mesmo número de trocas em seu processo de ordenação. Assim, independente se a entrada contem elementos organizados em ordem aleatória, crescente ou decrescente, o número de troca será o mesmo. Vale ressaltar ainda que conforme a quantidade de elementos aumenta, maior será o número de trocas formando um comportamento linear. Observe o gráfico apresentado na Figura \ref{graf:merge-troca}.

\begin{figure}[H]
\begin{center}
\pgfplotstableread{plots/swap/merge-sort-troca.dat}{\pistonkinetics}
\begin{tikzpicture}[scale=1.3]
\begin{axis}[minor tick num=1,
xlabel=n elementos]
\addlegendentry{Aleatório}
\addplot [black,very thick] table [x={n}, y={ale}] {\pistonkinetics};
\addlegendentry{Crescente}
\addplot [red,very thick] table [x={n}, y={cresc}] {\pistonkinetics};
\addlegendentry{Decrescente}
\addplot [blue,very thick] table [x={n}, y={desc}] {\pistonkinetics};
\end{axis}
\end{tikzpicture}
\end{center}
\caption{Número de trocas realizadas pelo algoritmo Merge Sort.}
\label{graf:merge-troca}
\end{figure}

\subsubsection{Heap Sort}

No caso do algoritmo Heap Sort, é constatado também que conforme o número de elementos a serem ordenados aumentam maior será o número de trocas em todas as configurações de entrada, formando um comportamento bem próximo ao linear. 

Contudo, existe uma mínima diferença entre a quantidade de trocas em cada configuração de entrada. A menor quantidade de trocas acontece quando a entrada de dados são elementos em ordem decrescente, já a maior quantidade de trocas ocorre quando os elementos está dispostos em ordem aleatória, caso os elementos estejam em ordem aleatória a quantidade de trocas é menor que a crescente e maior que a de ordem decrescente. Observe o gráfico apresentado na Figura \ref{graf:heap-troca}.

\begin{figure}[H]
\begin{center}
\pgfplotstableread{plots/swap/heap-sort-troca.dat}{\pistonkinetics}
\begin{tikzpicture}[scale=1.3]
\begin{axis}[minor tick num=1,
xlabel=n elementos]
\addlegendentry{Aleatório}
\addplot [black,very thick] table [x={n}, y={ale}] {\pistonkinetics};
\addlegendentry{Crescente}
\addplot [red,very thick] table [x={n}, y={cresc}] {\pistonkinetics};
\addlegendentry{Decrescente}
\addplot [blue,very thick] table [x={n}, y={desc}] {\pistonkinetics};
\end{axis}
\end{tikzpicture}
\end{center}
\caption{Número de trocas realizadas pelo algoritmo Heap Sort.}
\label{graf:heap-troca}
\end{figure}

~\\

\section{Considerações Finais}

Em suma, este estudo experimental buscou analisar e comparar o desempenho de diferentes abordagens e algoritmos de ordenação com o intuito de identificar características e melhores situações para utilização de cada método. Todas as análises, planilhas e implementações realizadas para a elaboração deste trabalho podem ser encontradas em: \url{https://github.com/brunoslima/Sorting-Algorithms-Analysis-Complexity}.

Os algoritmos \textit{Quick Sort} com pivô central, \textit{Shell Sort} e \textit{Heap Sort} apresentaram os melhores desempenhos dentro de suas respectivas abordagens de ordenação. Apesar de serem boas opções, vale ressaltar uma análise quanto ao contexto e necessidades da aplicação que tais algoritmos serão empregados, desse modo, desde implementações mais simples como o \textit{Insertion Sort} podem ser empregadas, principalmente em cenários que o conjunto de dados cresce por demanda, que nesse caso, é melhor opção devido a simplicidade e desempenho. Adicionalmente, vale lembrar o algoritmo \textit{Merge Sort} devido a estabilidade quanto a entrada de dados, porém, como ponto negativo, o consumo adicional de memória.

~\\
\begin{thebibliography}{9}

\bibitem{ziviani} 
ZIVIANI, Nivio. Projeto de Algoritmos: Com implementações em Pascal e C. São Paulo. Cengage Learning, 2011.

\bibitem{biggar}
BIGGAR, Paul. GREGG, David. Sorting in the Presence of Branch Prediction
and Caches Fast Sorting on Modern Computers. University of Dublin, 2005.

\bibitem{sedgewick}
SEDGEWICK, Robert. WAYNE, Kevin. Algorithms. 4 Ed. Addison-Wesley. 2001

\end{thebibliography}

% that's all folks
\end{document}


